<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Web of Things (WoT) Thing Description</title>
    <script src="https://www.w3.org/Tools/respec/respec-w3c-common" class="remove"></script>
    <script class='remove'>
var respecConfig = {
  specStatus: "ED",
  shortName: "wot-thing-description",
  copyrightStart:       2017,
  noLegacyStyle:        true,
  publishDate:          "",
  previousPublishDate:  "",
  previousMaturity:     "",
  edDraftURI:           "https://w3c.github.io/wot-thing-description/",
  crEnd:                "",
  inlineCSS:            true,
  noIDLIn:              true,
  format:               'markdown',
  editors: [
    { name: "Sebastian Kaebisch", company: "Siemens" },
    { name: "Takuki Kamiya", company: "Fujitsu" },
  ],
  wg:           "Web of Things Working Group",
  wgURI:        "https://www.w3.org/WoT/WG/",
  wgPublicList: "member-wot-wg@w3.org",
  issueBase: "https://www.github.com/w3c/wot-thing-description/issues/",
  githubAPI: "https://api.github.com/repos/w3c/wot-thing-description",
  otherLinks: [
    {
      key: "Repository",
      data: [{
            value: "We are on Github.",
            href: "https://github.com/w3c/wot-thing-description"
        }, {
            value: "File a bug.",
            href: "https://github.com/w3c/wot-thing-description/issues"
        }, {
            value: "Commit history.",
            href: "https://github.com/w3c/wot-thing-description/commits/"
        }, {
            value: "Use cases",
            href: "https://github.com/w3c/wot-thing-description/use-cases.html"
        }
      ]
    },
    {
      key: "Contributors",
      data: [
          {
            value: "In the github repository",
            href: "https://github.com/w3c/wot-thing-description/graphs/contributors"
          }
      ]
    },
  ],
};
    </script>
<style>
.example {
		border-color: #EA1252;
		background: #FEF11E;
		counter-increment: example;
		overflow: auto;
		clear: both;
	}
</style>
  </head>
  <body>

  <section id="abstract">
This document describes a common data model for the Web of Things. The W3C Web of Things Thing Description provides a narrow-waist set of vocabulary for describing physical and/or virtual Things in a machine readable format with a default JSON-LD encoding. A Thing Description instance can be hosted by the Thing itself or hosted externally due to Thing's resource restrictions (e.g. limited memory space) or when a Web of Thing-compatible legacy device is retrofitted with a Thing Description.

<!-- for devices.
The TD must be acquired to use and interact with the Thing, since it describes the semantics of a Thing as well as its <a>WoT Interface</a>. Usually, Things directly provide their own TD, but the TD can also be hosted externally if there is not enough space on the device or when a WoT-compatible legacy device is retrofitted with a TD.-->
  </section>

  <section id="sotd">
  <p>
    Implementers need to be aware that this specification is considered unstable. Vendors interested in implementing this specification before it eventually reaches the Candidate Recommendation phase should subscribe to the [repository](https://github.com/w3c/wot-thing-description) and take part in the discussions.
  </p>
  </section>

  <section id="introduction">
    <h1>Introduction</h1>
    <p>
The W3C Thing Desccription (TD) is a central building block in a Web of Things (WoT) enabled system and can be considered as the entry point of a Thing (aka the <i>index.html</i> of the Thing). The TD comprises of semantic metadata for the Thing itself, a narrow-waist interaction model with WoT's Properties, Actions, and Events, a semantic schema to make data models machine-understandable, and features for Web Linking to express relations among Things. 
</p>
<p>
Properties can be used for controlling parameters, such as a set point or operation state. Actions model invocation of physical processes, but can also be used to abstract RPC-like calls of existing platforms. Events cover the push model where state change notifications, discrete events, and streams of values are sent asynchronously to the receiver. In general, the TD provides metadata for the different communication bindings (e.g., HTTP, CoAP, (MQTT?), etc.), mediaTypes (e.g., "application/json", "application/xml", "application/cbor", "application/exi" etc.), and security policies (authentication, authorization, etc.). The default serialisation of the TD is JSON-LD.
</p>

<p>
Example 1 shows a simple TD instance that describes a lamp Thing with the name <i>MyLampThing</i>.
</p>

<pre class="example" title="Simple Thing Description Sample">
  {
    "@context": ["http://w3c.github.io/wot/w3c-wot-td-context.jsonld"],
    "@type": "Thing",
    "name": "MyLampThing",
    "interactions": [
        {
            "@type": ["Property"],
            "name": "status",
            "outputData": {"type": "string"},
            "writable": false,
            "links": [{
                "href": "coaps://mylamp.example.com:5683/status",
                "mediaType": "application/json"
            }]
        },
        {
            "@type": ["Action"],
            "name": "toggle",
            "links": [{
                "href": "coaps://mylamp.example.com:5683/toggle",
                "mediaType": "application/json"
            }]
        },
        {
            "@type": ["Event"],
            "name": "overheating",
            "outputData": {"type": "string"},
            "links": [{
                "href": "coaps://mylamp.example.com:5683/oh",
                "mediaType": "application/json"
            }]
        }
    ]
  }
 </pre>





<p>Based on this content, we know there exists one Property interaction resource with the name <i>status</i>. In addition, information is provided such as that this Property is accessable over the CoAP protocol with a GET method (see CoAP protocol binding description in the W3C WoT protocol template deliverable [XXX]) at coaps://mylamp.example.com:5683/status (announced within the endoind structure by the <code>href</code> kye), which will return a string status value within a JSON structure (JSON as payload format is announced by the <code>mediaType</code> field).
</p>

<p class="issue">
Short explanation of the example.
</p>
</section>

  
  <section>
    <h1>Namespaces</h1>

<p>
The namespace for TD is http://www.w3.org/ns/td#. TD itself defines a minimal set of classes and properties of its own. A full set of namespaces and prefixes used in this document is shown in the table below.
</p>

<table id="namespacesTable">
  <thead><tr><th>Prefix</th><th>Namespace</th></tr></thead>
  <tbody>
     <tr><td>rdf</td><td>http://www.w3.org/1999/02/22-rdf-syntax-ns#</td></tr>
    <tr><td>rdfs</td><td>http://www.w3.org/2000/01/rdf-schema#</td></tr>
    <tr><td>xsd</td><td>http://www.w3.org/2001/XMLSchema#</td></tr>
  </tbody>
</table>


<p class="issue">
ToDo: complete table
</p>
</section>
<section>
    <h1>Conformance</h1>

<p>
  As well as sections marked as non-normative, all authoring guidelines, diagrams, examples,   and notes in this specification are non-normative. Everything else in this specification is
  normative.
</p>
<p>
  The key words <em title="MUST" class="rfc2119">MUST</em>, <em title="MUST NOT" class="rfc2119">MUST NOT</em>, <em title="REQUIRED" class="rfc2119">REQUIRED</em>, <em title="SHOULD" class="rfc2119">SHOULD</em>, <em title="SHOULD NOT" class="rfc2119">SHOULD NOT</em>, <em title="RECOMMENDED" class="rfc2119">RECOMMENDED</em>, <em title="MAY" class="rfc2119">MAY</em>,
  and <em title="OPTIONAL" class="rfc2119">OPTIONAL</em> in this specification are to be interpreted as described in [<cite><a href="#bib-RFC2119" class="bibref">RFC2119</a></cite>].
</p>

 


<table id="namespacesTable">
  <tbody>
     <tr><td>A Thing Description instance complies with this specification if it follows the normative statements in Section <a href="#vocabularyDefinitionSection" class="sec-ref"><span class="secno">3.</span> <span class="sec-title">Vocabulary Definition</span></a>.</td> </tr>
    <tr><td>In case of JSON-LD serializiation, a Thing Description instance in JSON-LD format complies with this specification if it follows the normative statements in Section <a href="#serialization" class="sec-ref"><span class="secno">4.</span> <span class="sec-title">Serialization</span></a></td> </tr>
   </tbody>
</table>
 

<p class="issue">
How to validate TD? RDF validation? Structure validation?
</p>

</section>



  <section id="vocabularyDefinitionSection"><h1>Vocabulary Definition</h1><!-- h1>Vocabulary</h1 --><section><h1>Overview</h1><p>The Thing Description relys on a small set of vocabulary. An overview of this vocabulary with its class context and class relation is given by the following figure.</p><center><img src="td-core-model/td-core-model.svg"  /></center><p>A detailed description of the vocabulary is given in the next sub-section.</p></section><section><h2>Classes</h2><p class="ednote">There is an information missing which vocabulary is optional or manditory.</p><h3><code>Thing</code></h3><p>Describs a physical and/or virtual Thing (may represent one or more physical and / or virtual Things) in the Web of Thing context.</p><table class="def"><thead><tr><th>Field Name</th><th>Optional / Mandatory</th><th>Description</th><th>Expected value type</th></tr></thead><tbody><tr><td><code>interaction</code></td><td></td><td>Link from a Thing to the interaction patterns it provides</td><td><a href="#interactionpattern"><code>InteractionPattern</code></a></td></tr><tr><td><code>security</code></td><td></td><td>Links a given Thing to the security information that indicates the access metadata information for securely transmitting information via all the resources of the Thing.</td><td><a href="#security"><code>Security</code></a></td></tr><tr><td><code>base</code></td><td></td><td>Define base URI that is valid for all defined local interaction resources. All other URIs in the TD must then be resolved using the algorithm defined in [RFC3986]. This field is optional.</td><td><a href="http://www.w3.org/2001/XMLSchema#string"><code>string</code></a></td></tr><tr><td><code>name</code></td><td></td><td>Name of the Thing or interaction pattern (must be a valid keyword to be used in the scripting API)</td><td><a href="http://www.w3.org/2001/XMLSchema#string"><code>string</code></a></td></tr></tbody></table><h3><code>InteractionPattern</code></h3><p>An interaction in the context of the Web of Things may an exchange of data between a Web client and a Thing. This data can be either given as input by the client, returned as output by the Thing or both. Three interaction patterns have been defined so far: Property, Action and Event.</p><table class="def"><thead><tr><th>Field Name</th><th>Optional / Mandatory</th><th>Description</th><th>Expected value type</th></tr></thead><tbody><tr><td><code>link</code></td><td></td><td>Indicates the endpoints from which an interaction pattern is accessible</td><td><a href="#link"><code>Link</code></a></td></tr><tr><td><code>name</code></td><td></td><td>Name of the Thing or interaction pattern (must be a valid keyword to be used in the scripting API)</td><td><a href="http://www.w3.org/2001/XMLSchema#string"><code>string</code></a></td></tr></tbody></table><p>The class <code>InteractionPattern</code> has the following subclasses:</p><ul><li><td><a href="#action"><code>Action</code></a></td></li><li><td><a href="#event"><code>Event</code></a></td></li><li><td><a href="#property"><code>Property</code></a></td></li></ul><h3><code>Property</code></h3><p>Property provides readable and/or writeable data that can be static (e.g., supported mode, rated output voltage, etc.) or dynamic (e.g., current fill level of water, minimum recorded temperature, etc.).  Please note, this class also inherited all vocabulary from the InteractionPattern class.</p><table class="def"><thead><tr><th>Field Name</th><th>Optional / Mandatory</th><th>Description</th><th>Expected value type</th></tr></thead><tbody><tr><td><code>outputData</code></td><td></td><td>link to the n-ary class that allows the declaration of the data type and unit of measure provided by an interaction pattern.</td><td><a href="#dataschema"><code>DataSchema</code></a></td></tr><tr><td><code>isWritable</code></td><td></td><td>Boolean value that indicates whether a property is writable (=true) or not (=false)</td><td><a href="http://www.w3.org/2001/XMLSchema#boolean"><code>boolean</code></a></td></tr></tbody></table><h3><code>Action</code></h3><p>The Action interaction pattern targets changes or processes on a Thing that take a certain time to complete (i.e., actions cannot be applied instantaneously like property writes). Examples include an LED fade in, moving a robot, brewing a cup of coffee, etc. Usually, ongoing Actions are modelled as Task resources, which are created when an Action invocation is received by the Thing. Please note, this class also inherited all vocabulary from the InteractionPattern class.</p><table class="def"><thead><tr><th>Field Name</th><th>Optional / Mandatory</th><th>Description</th><th>Expected value type</th></tr></thead><tbody><tr><td><code>outputData</code></td><td></td><td>link to the n-ary class that allows the declaration of the data type and unit of measure provided by an interaction pattern.</td><td><a href="#dataschema"><code>DataSchema</code></a></td></tr><tr><td><code>inputData</code></td><td></td><td>link to the n-ary class that allows the declaration of the data type and unit of measure expected by an interaction pattern.</td><td><a href="#dataschema"><code>DataSchema</code></a></td></tr></tbody></table><h3><code>Event</code></h3><p>The Event interaction pattern enables a mechanism to be notified by a Thing on a certain condition. Please note, this class also inherited all vocabulary from the InteractionPattern class.</p><table class="def"><thead><tr><th>Field Name</th><th>Optional / Mandatory</th><th>Description</th><th>Expected value type</th></tr></thead><tbody><tr><td><code>outputData</code></td><td></td><td>link to the n-ary class that allows the declaration of the data type and unit of measure provided by an interaction pattern.</td><td><a href="#dataschema"><code>DataSchema</code></a></td></tr></tbody></table><h3><code>DataSchema</code></h3><p>N-ary class defined to allow the representation of pairs (data type, unit of measure) that are expected as input data or output data of a given interaction pattern.</p><h3><code>Link</code></h3><p>Communication metadata where a service can be accessed by a client application. An interaction might have more than one link.</p><table class="def"><thead><tr><th>Field Name</th><th>Optional / Mandatory</th><th>Description</th><th>Expected value type</th></tr></thead><tbody><tr><td><code>href</code></td><td></td><td>URI of the endpoint where an interaction pattern is provided</td><td><a href="http://www.w3.org/2001/XMLSchema#string"><code>string</code></a></td></tr><tr><td><code>mediaType</code></td><td></td><td>Assign underlying media type of the interaction pattern based on IANA (https://www.iana.org/assignments/media-types/media-types.xhtml)</td><td><a href="http://www.w3.org/2001/XMLSchema#string"><code>string</code></a></td></tr></tbody></table><h3><code>Security</code></h3><p>The (optional) security field can be used to provide access metadata (self-contained) information of the Thing for securely transmitting information via all its resources. Definition taken from http://w3c.github.io/wot/current-practices/wot-practices#security</p></section></section>

  <section>
    <h1>Serialization</h1>

      <p class="ednote">Currently, JSON-LD is seen as baseline for TD serialization. In TD task force alternatives are evaluated.
      </p>

  <section>
    <h2>JSON-LD</h2>
<p>
  W3C <a href="https://www.w3.org/TR/json-ld/">JSON-LD</a> is a serialization format that adds a semantic layer on top of the JSON specification: the terms that appear in a JSON document
  should be associated with uniquely identified concepts from shared vocabularies. This principle is part of a set of practices to publish data
  on the Web called Linked Data, where concepts are usually identified with URIs and originate from RDF vocabularies.
</p>
   </section>

  <section>
    <h2>Parsing</h2>
<p>
To parse a valid Thing Description a simple JSON-based parser and tools can be used to retrieve the content. To validate and follow the references of external used context vocabulary, JSON-LD or RDF-based parsing tools and libraries are highly recommended.   
</p>
   </section>
 
    <section>
      <h2><code>@context</code></h2>

<p>
The  <code>@context</code> key is used to define Thing Description's context. All JSON key terms that are defined in the present document (also see <a href="#vocabularyDefinitionSection">Vocabulary Definition Section</a> ) have been put in an external context document, available at
  <code>https://www.w3.org/ns/td/w3c-wot-td-context.jsonld</code>. Each Thing Description instance in JSON-LD shall include this context information enmbedded within an JSON array structure. Thus, a basic Thing Description would contain the following declaration:
</p>

  <pre class="example">
    {
      "@context": ["https://www.w3.org/ns/td/w3c-wot-td-context.jsonld"],
      ...
    }
  </pre>

<p>
  In case a single Thing Description instance involves several contexts, additional namespaces with prefixs can be extended to the <code>@context</code> array structure. This option proves relevant if one wants to extend the existing Thing Description context without modifying it. For instance:
</p>
  <pre class="example">
    {
      "@context": ["https://www.w3.org/ns/td/w3c-wot-td-context.jsonld",
                   {"sensor": "http://example.org/sensors#"}],
      ...
    }
  </pre>

<p>
  Section <a href="#td-context-extension"></a> provides a more concrete example on that topic.
</p>
    </section>

    <section>

    </section>

    <section>
      <h2>Thing Metadata</h2>

      <p>A Thing Description will provide some generic Thing metadata vocabularies (also see <a href="#thing">Thing vocabulary definition section</a>) that can be used, e.g., 
      to assign a name or what kind of base URI does a servient support.</p>
      <pre class="example">
        {
          ...
          "name": "MyLED",
          "base": "coap://myled.example.com:5683/"
          ...
        }
      </pre>


      <p>
        <b>Note:</b> Besides these pre-defined terms in the Thing Description context, additional characteristics can be
        added to Thing level such as product ID, firmware version, location, etc. These terms should then appear in the context of the Thing (as detailed in <a href="#td-context"></a>).
      </p>

      <p class="ednote">This note should be moved to the td-context-extension definition. In there it should be also explained that a context is not necessary if you are working outside of the RDF model and if you handle a TD just as a simple JSON document.
      </p>

    </section>
 
<h2>Security</h2>

<pre class="example">
  {
    ...
    "security": {"cat":"token:jwt", "alg":"HS256", "as":"https://authority-issuing.org"},
    ...
  }
</pre>

The <b>(optional)</b> security field can be used to provide access metadata (self-contained) information of the Thing
for securely transmitting information via all its resources (also see <a href="#security">Security vocabulary definition section</a>). Also see Section <a href="#security-1">Security</a>.


<p>Here as a example, JSON Web Token (JWT) type is assigned (cat), the corresponding hashing algorithm "HS256" (alg), and
issuing authority of the security token (as).</p>

      <p class="ednote">Do we need a context definition for that example?
      </p>

  <section>
    <h1>Interaction Patterns</h1>

    <p>
      An interaction in the context of the Web of Things is an exchange of data between a Web client and a Thing.
      This data can be either given as input by the client, returned as output by the Thing or both.
      Three interaction patterns have been defined so far: Property, Action and Event.
    </p>
  
    <section>
      <h3>Property</h3>
  
      <p>
        The <code>Property</code> interaction (also see <a href="#property">Property vocabulary definition section</a>) provides readable and/or writeable data that can be static (e.g., supported mode, rated output voltage, etc.) or 
        dynamic (e.g., current fill level of water, minimum recorded temperature, etc.).
      </p>

      <pre class="example">
        {
          ...
          "interaction": [
            {
              "@type": ["Property"],
              "name": "temperature",
              "outputData":{ "type": "number" },
              "writable": false,
              "link": [{
                "href" : "coap://mytemp.example.com:5683/temp",
                "mediaType": "application/json"
              }],
            },
          ...
        }
      </pre>

    </section>
  
    <section>
      <h3>Action</h3>
  
      <p>
        The <code>Action</code> interaction pattern (also see <a href="#action">Action vocabulary definition section</a>) targets changes or processes on a Thing that take a certain time to complete (i.e., actions cannot be applied instantaneously like property writes).
        Examples include an LED fade in, moving a robot, brewing a cup of coffee, etc.
        Usually, ongoing Actions are modelled as Task resources, which are created when an Action invocation is received by the Thing.
      </p>
  
      <pre class="example">
        {
          ...
          "interaction": [
            {
              "@type": ["Action"],
              "name": "fadeIn",
              <i>"inputData":</i> { "type": "integer" },
              "link": [{
              	"href" : "coap://mytemp.example.com:5683/in",
              	"mediaType": "application/json"
              }]
            }
          ]
          ...
        }
      </pre>

    </section>
  
    <section>
      <h3>Event</h3>
  
      <p>
        The <code>Event</code> interaction pattern (also see <a href="#event">Event vocabulary definition section</a>) enables a mechanism to be notified by a Thing on a certain condition.
        While some protocols such as CoAP can provide such a mechanism natively, others do not.
        Furthermore, Events might need a specific configuration that requires data sent and stored on the Thing in a standard way.
        There are are two mandatory and two optional terms defined within the <code>Event</code> pattern:
      </p>
  
      <pre class="example">

        {
          ...
          "interaction": [
            {
              "@type": ["Event"],
              "name": "criticalCondition",
              "outputData":  { "type": "string" },
              "link": [{
              	"href" : "coap://mytemp.example.com:5683/ev",
              	"mediaType": "application/json"
              }]
            }
          ]
          ...
        }
      </pre>

    </section>




  </section>

  <section>
    <h1>Type System</h1>

    <p>All of the three interaction types <code>Property</code>, <code>Action</code>, and <code>Event</code> can specify the type of the value acceptable as an input or expected as an output of the interaction. JSON schema [[!draft-zyp-json-schema-04]] [[!draft-fge-json-schema-validation-00]] provides a standard way to describe the structure and datatypes of data, and we use JSON schema as the notation for value types of the interaction types.
    </p>

    <p>
      <b>Note:</b> In the embodiment of type system described in this section, JSON schema is used as an abstract description system for structured data. 
      JSON schema is something that is already out there being used and well-known, therefore gives us a chance to get started quickly to experiment with type system idea for further contemplation. 
      Through discussion, the following points have been noted as feedback for improvements.
    </p>
      <ul>
        <li>JSON schema specification was designed for JSON, therefore, may not be an optimal solution as an encoding-neutral description system.</li>
        <li>JSON schema does not provide a way to associate data elements with citations or semantic concepts defined elsewhere.</li>
        <li>JSON schema is relatively verbose.</li>
        <li>JSON schema is not a formal standard.</li>
      </ul>
    <p>
      Note that the current plan is to use JSON-LD syntax to express the function of at least part of what JSON schema provides. This will enable Type System to allow the association of semantics while it remains compatible with JSON schema.
    </p>

    <p>For <code>Property</code> and <code>Event</code> interaction types, each property or event can specify its value type using <code>outputData</code> with JSON schema definition as its content. In the following example, <code>temperature</code> property and <code>criticalCondition</code> event are defined as  <code>number</code> and <code>string</code>, respectively.
    </p>

    <pre class="example">
      {
        ...
        "properties": [
          {
            ...
            "name": "temperature",
            "outputData": { "type": "number" },
            ...
          }
        ]
        ...
        "events": [
          {
            ...
            "name": "criticalCondition",
            "outputData": { "type": "string" },
            ...
          }
        ]
        ...
      }
    </pre>

    <p>Similarly, for <code>Action</code> interaction type, each action can specify its input and/or output value type with JSON schema definition as its content. The following is an example value type definition for an action. In the example, <code>fadeIn</code> action is defined to have <code>inputData</code> of type <code>number</code> and <code>outputData</code> of type <code>boolean</code>.
    </p>

    <pre class="example">
      {
        ...
        "actions": [
          {
            ...
            "name": "fadeIn",
            "inputData": {
              "valueType": { "type": "number" },
              "actuator:unit": "actuator:ms"
            },
            "outputData": {
              "valueType": { "type": "boolean" },
            },
            ...
          }
        ]
        ...
      }
    </pre>

    <section>
      <h4>Simple Data</h4>
      <p>With value types described by means of JSON schema, serialization of data exchanged between servients is straightforward when it is in JSON format. JSON Schema allows the following definitions in the <code>type</code> field:
        <ul>
          <li>boolean</li>
          <li>integer</li>
          <li>number</li>
          <li>string</li>
          <li>array</li>
          <li>object</li>
        </ul>
      </p>
	
      <p>Consider the following <code>inputData</code> definition which defines the value to be an <code>integer</code> within the value range of [ 0 ... 255 ].
      </p>

      <pre class="example">
        "inputData": { 
          "type": "integer",
          "minimum": 0,
          "maximum": 255,
        }
      </pre>

      <p>When the <code>integer</code> being exchanged is 123, data serialization in JSON format will look like the following:
      </p>

      <pre class="example">
        123
      </pre>

      <p>The snippet in the above example is a valid JSON document according to the syntax defined in [[!RFC7159]], which allows sending simple types in the root of the document. There is no need for wrapping a single value into an object.
      </p>

      <p>The same data (i.e. a number of 123) will look like the following when the data is exchanged in XML.
      </p>

      <pre class="example">
      		&lt;integer>123&lt;/integer>
      </pre>

    </section>
  
    <section>
      <h4>Structured Data</h4>
  
      <p>In the previous section, we used an example <code>inputData</code> definition consisting of a single <code>integer</code>.
      </p>
	
      <p>Since we are using JSON schema to describe <code>inputData</code>, it is also possible to define value types that have more than one literal value.
      JSON provides two distinct constructs to define a structure that can have multiple literal values. 
      One is JSON object, and the other is JSON array.
      </p>

      <section>
        <h5 id="json-object">JSON Object</h5>
    
        <p>The following is an example <code>valueType</code> definition that defines the value to be an <code>object</code> that consists of
        two named literals  <code>id</code> (of type <code>integer</code>) and <code>name</code> (of type <code>string</code>)
        where <code>id</code> is required to be present.
        </p>
    
        <pre class="example">
          "inputData": {
              "type": "object",
              "properties": {
                  "id": {
                      "type": "integer"
                  },
                  "name": {
                      "type": "string"
                  }
              },
              "required": ["id"]
          }
        </pre>
    
        <p>When the <code>id</code> number and the <code>name</code> string values being exchanged are 12345 and "Web of Things", data serialization in JSON format will look like the following.
        </p>
    
        <pre class="example">
          {
            "id": 12345,
            "name": "Web of Things"
          }
        </pre>
    
        <p>The above data will look the following when the data is exchanged in XML.
        </p>
    
        <pre class="example">
            &lt;object>
              &lt;id>
                &lt;number>12345&lt;/number>
              &lt;/id>
              &lt;name>
                &lt;string>Web of Things&lt;/string>
              &lt;/name>
            &lt;/object>
        </pre>

      </section>
  
      <section>
        <h5 id="json-array">JSON Array</h5>
    
        <p>The following is an example <code>valueType</code> definition that defines the value to be an <code>array</code> that consists of
        exactly three number literals with each value within the range of [ 0 ... 255 ].
        </p>
    
        <pre class="example">
          "inputData": {
              "type": "array",
              "items": {
                  "type" : "number",
                  "minimum": 0,
                  "maximum": 255
              },
              "minItems" : 3,
              "maxItems" : 3
          }
        </pre>
    
        <p>When the numbers being exchanged are 208, 32 and 144, data serialization in JSON format will look like the following.
        </p>
    
        <pre class="example">
          [
            208,
            32,
            144
          ]
        </pre>
    
        <p>The above data will look the following when the data is exchanged in XML.
        </p>
    
        <pre class="example">
            &lt;array>
              &lt;number>208&lt;/number>
              &lt;number>32&lt;/number>
              &lt;number>144&lt;/number>
            &lt;/array>
        </pre>
    
    
      </section><!-- End of "JSON Array" -->
  
    </section><!-- End of "Structured Data" -->
  
    <section>
    <h4>Mapping to XML Schema</h4>

      <p>In the previous section, examples showed what those data whose value type are described using JSON schema
      look like when serialized to XML in parallel to corresponding JSON serializations.
      </p>

      <p>This section describes how JSON schema definitions can be mapped to XML schema definitions by using the same examples.
      Given JSON schema definitions, providing the mapping to XML schema allows XML tools to directly validate serialized XML data, for example.
      </p>

      <p>The XML structure is based on EXI4JSON [[!exi-for-json]].
      The structure works uniformly well for both schema-less and schema-informed use cases. 
      </p>

      <p class="ednote">A complete "JSON Schema" to "XML Schema" mapping needs to be defined. 
      </p>

    <section>
      <h5>JSON Object Definition to XML Schema</h5>

      <p>Shown below is the JSON schema <code>object</code> definition used as the <code>inputData</code> in Section <a href="#json-object">JSON Object</a>. The <code>object</code> consists of two named literals <code>id</code> (of type <code>integer</code>) and <code>name</code> (of type <code>string</code>) where <code>id</code> is required to be present.
      </p>

      <pre class="example">
        {
            "type": "object",
            "properties": {
                "id": {
                    "type": "integer"
                },
                "name": {
                    "type": "string"
                }
            },
            "required": ["id"]
        }
      </pre>

      <p>When the <code>object</code> is anonymous (i.e. it is the root, or participates in an <code>array</code> definition), 
      the above <code>object</code> definition transforms to the following XML Schema element definition.
      </p>

      <pre class="example">
        &lt;xs:element name="object" xmlns:xs="http://www.w3.org/2001/XMLSchema">
            &lt;xs:complexType>
                &lt;xs:all>
                    &lt;xs:element name="id">
                        &lt;xs:complexType>
                          &lt;xs:sequence>
                            &lt;xs:element name="integer" type="xs:integer" />
                          &lt;/xs:sequence>
                        &lt;/xs:complexType>
                    &lt;/xs:element>
                    &lt;xs:element name="name" minOccurs="0">
                        &lt;xs:complexType>
                          &lt;xs:sequence>
                            &lt;xs:element name="string" type="xs:string" />
                          &lt;/xs:sequence>
                        &lt;/xs:complexType>
                    &lt;/xs:element>
                &lt;/xs:all>
            &lt;/xs:complexType>
        &lt;/xs:element>
        </pre>
  
        <p class="ednote">JSON schema <code>object</code> does NOT define any order. 
        Therefore, in order to capture the constraints of JSON schema <code>object</code>, 
        we need to use xsd:all constructs instead of xsd:sequence.
        </p>
  
        <p>Otherwise (i.e. the <code>object</code> is a member of another <code>object</code> definition, thus has a name), 
        the <code>object</code> definition transforms to the following XML schema element definition.
        Note <code><i>__name</i></code> should be replaced by the actual name of the <code>object</code>.
        </p>
  
        <pre class="example">
          &lt;xs:element name="<i>__name</i>" xmlns:xs="http://www.w3.org/2001/XMLSchema">
              &lt;xs:complexType>
                  &lt;xs:sequence>
                      &lt;xs:element name="object">
                          &lt;xs:complexType>
                              &lt;xs:all>
                                  &lt;xs:element name="id">
                                      &lt;xs:complexType>
                                        &lt;xs:sequence>
                                          &lt;xs:element name="integer" type="xs:integer" />
                                        &lt;/xs:sequence>
                                      &lt;/xs:complexType>
                                  &lt;/xs:element>
                                  &lt;xs:element name="name" minOccurs="0">
                                      &lt;xs:complexType>
                                        &lt;xs:sequence>
                                          &lt;xs:element name="string" type="xs:string" />
                                        &lt;/xs:sequence>
                                      &lt;/xs:complexType>
                                  &lt;/xs:element>
                              &lt;/xs:all>
                          &lt;/xs:complexType>
                      &lt;/xs:element>
                  &lt;/xs:sequence>
              &lt;/xs:complexType>
          &lt;/xs:element>
        </pre>
  
      </section><!-- End of "JSON Object Definition to XML Schema" -->

      <section>
        <h5>JSON Array Definition to XML Schema</h5>

          <p>Shown below is the JSON schema <code>array</code> definition used as the <code>inputData</code> in Section <a href="#json-array">JSON Array</a>. 
          The <code>array</code> consists of exactly three number literals with each value within the value range of [ 0 ... 255 ].</p>

        <pre class="example">
          {
              "type": "array",
              "items": {
                  "type" : "number"
                  "minimum": 0,
                  "maximum": 255,
              },
              "minItems" : 3,
              "maxItems" : 3
          }
        </pre>
  
        <p>When the <code>array</code> is anonymous (i.e. it is the root, or participates in another <code>array</code> definition), 
        the above <code>array</code> definition transforms to the following XML Schema element definition.
        </p>
  
        <pre class="example">
          &lt;xs:element name="array" xmlns:xs="http://www.w3.org/2001/XMLSchema">
              &lt;xs:complexType>
                  &lt;xs:sequence>
                      &lt;xs:element name="double" minOccurs="3" maxOccurs="3">
                          &lt;xs:simpleType name="minInclusive">
                              &lt;xs:restriction base="xs:double">
                                  &lt;xs:minInclusive value="0"/>
                                  &lt;xs:maxInclusive value="255"/>
                              &lt;/xs:restriction>
                          &lt;/xs:simpleType>
                      &lt;/xs:element>
                  &lt;/xs:sequence>
              &lt;/xs:complexType>
          &lt;/xs:element>
        </pre>

        <p>Otherwise (i.e. the <code>array</code> is a member of an <code>object</code> definition, thus has a name), 
        the <code>array</code> definition transforms to the following XML schema element definition.
        Note <code><i>__name</i></code> should be replaced by the actual name of the <code>array</code>.
        </p>

        <pre class="example">
          &lt;xs:element name="<i>__name</i>" xmlns:xs="http://www.w3.org/2001/XMLSchema">
              &lt;xs:complexType>
                  &lt;xs:sequence>
                      &lt;xs:element name="array">
                          &lt;xs:complexType>
                              &lt;xs:sequence>
                                  &lt;xs:element name="double" minOccurs="3" maxOccurs="3" >
                                      &lt;xs:simpleType name="minInclusive">
                                          &lt;xs:restriction base="xs:double">
                                              &lt;xs:minInclusive value="0"/>
                                              &lt;xs:maxInclusive value="255"/>
                                          &lt;/xs:restriction>
                                      &lt;/xs:simpleType>
                                  &lt;/xs:element>
                              &lt;/xs:sequence>
                          &lt;/xs:complexType>
                      &lt;/xs:element>
                  &lt;/xs:sequence>
              &lt;/xs:complexType>
          &lt;/xs:element>
        </pre>
  
      </section><!-- End of "JSON Array Definition to XML Schema" -->

    </section><!-- End of "Mapping to XML Schema" -->


    </section><!-- End of "Mapping to XML Schema" -->
  <section>
    <h2>Examples</h2>

    <p>
      In the following, we give three examples of a full TD. The first one, a
      temperature sensor, shows how to define relations between Thing
      Properties. As a second example, we modeled
      an actuator (LED lamp) where Actions have all been characterized semantically,
      so that machines could unambiguously interpret them in an automated manner.
      At last, association between Things is shown by defining a master switch
      controlling other LED lamps.
    </p>

    <section>
      <h4>Temperature Sensor</h4>

      <pre class="example">
        {
          "@context": ["https://w3c.github.io/wot/w3c-wot-td-context.jsonld",
                       "https://w3c.github.io/wot/w3c-wot-common-context.jsonld"],
          "@type": "Sensor",
          "name": "myTempSensor",
          "base" : "coap:///www.example.com:5683/temp/",
          "interaction": [
            {
              "@id": "val",
              "@type": ["Property","Temperature"],
              "unit": "celsius",
              "reference": "threshold",
              "name": "myTemp",
              "outputData": { "type": "number" },
              "writable": false,
              "link": [{
              	"href" : "val",
              	"mediaType": "application/json"
              }]
            }, 
            {
              "@id": "threshold",
              "@type": ["Property","Temperature"],
              "unit": "celsius",
              "name": "myThreshold",
              "outputData": { "type": "number" },
              "writable": true,
             	"link": [{
              	"href" : "thr",
              	"mediaType": "application/json"
              }]
            },
            {
              "@type": ["Event"],
              "outputData": { "type": "number" },
              "name": "myChange",
              "property": "temp",
              "link": [{
              	"href" : "val/changed",
              	"mediaType": "application/json"
              }]
            }, 
            {
              "@type": ["Event"],
              "outputData":  { "type": "number" },
              "name": "myWarning",
              "link": [{
              	"href" : "val/high",
              	"mediaType": "application/json"
              }]
            }
          ]
        }
      </pre>

      <p>
        The Thing <code>myTempSensor</code> defines two Properties: <code>myTemp</code>
        and <code>myThreshold</code>. Both are defined as temperatures, with the same unit
        (<code>celsius</code>). A client that is able to parse a TD only needs to know
        the predicate <code>reference</code> to understand that the threshold acts as
        a reference value for <code>myTemp</code> while the latter is the actual
        value measured by the temperature sensor. Here, <code>reference</code> points
        to <code>http://schema.org/valueReference</code>.
      </p>

      <p>
        Moreover, one of the Events of the Thing is linked to the measured value
        (with the predicate <code>property</code>). It means
        in that context that an event should be triggered each time <code>myTemp</code>
        changes. The other Event does not define further semantics, it could be used either
        in a closed system (where clients are aware of its meaning) or by a human but
        an external agent would not have sufficient information to interpret it.
      </p>
    </section>
    <section>
      <h4>LED Master Switch</h4>
      <pre class="example">
        {
          "@context": ["https://w3c.github.io/wot/w3c-wot-td-context.jsonld",
                       "https://w3c.github.io/wot/w3c-wot-common-context.jsonld"],
          "@type": "Lamp",
          "name": "myMasterLED",
          "interaction": [
            {
              "@type": ["Actions", "Toggle"],
              "name": "myMasterOnOff",
              "inputData": {
                "@type": "OnOff",
                "type": "boolean"
              },
              "link": [
                {
                  "href" : "coap://www.example.com:5683/master",
                  "mediaType": "application/json"
                },
                {
                  "href" : "http://www.example.com:80/master",
                  "mediaType": "application/json"
                }
              ]
            }
          ],
          "associations": [
            { "hrefs": ["coap://www.example.com:5683/0"] },
            { "hrefs": ["coap://www.example.com:5683/1"] },
            { "hrefs": ["coap://www.example.com:5683/2"] },
            { "hrefs": ["coap://www.example.com:5683/3"] },
            { "hrefs": ["coap://www.example.com:5683/4"] },
            { "hrefs": ["coap://www.example.com:5683/5"] },
            { "hrefs": ["coap://www.example.com:5683/6"] },
            { "hrefs": ["coap://www.example.com:5683/7"] }
          ]
        }
      </pre>

      <p>
        In this last example, we illustrate the use of <code>associations</code>.
        The Thing we modeled here acts as a master switch for eight lamps similar
        to that of <a href="#led-actuator"></a>. It means switching on and off
        <code>myMasterOnOff</code> will propagate to all associated Things
        by toggling their Action that is also of type <code>Toggle</code>.
      </p>

      <p>
        No precise semantics for <code>associations</code> have been defined yet
        and there might exist many other kinds of dependency between Things than
        simply parent/child relation. This issue will be addressed soon. Until then,
        Thing associations could be useful for discovery.
      </p>


  </section>
  </section>
 
  </section>
    

    
    <section>
      <h4>Security</h4>
      
      @TODO Add howto about security metadata and how to use it; WIP
	    <h5>Requirements</h5>
	    <ol>
	    <li>Threat model: assets (TD itself, and then the resources that can be accessed via the TD);
		    risks; adversaries; and prioritized threats.</li>
	    <li>General: that we "do no harm": security of described protocols should be maintained.
		    Don't introduce new security mechanisms, but do preserve functionality of existing mechanisms.</li>
            <li>Exposing: 
		    when exposing a TD, especially via the Scripting API, it should be possible to use best practices for security.</li>
            <li>Consuming:
		    a consumed TD should accurately reflect the actual security status of a target device.</li>
            <li>Protocols:
		    we will ensure in particular that the needs of the following protocols are addressed: http(s), coap(s).
	    </ol>
	    
	    <h5>Recommended Practices</h5>
	    Here is a set of recommended practices for enhancing security and privacy.
            <h6>Secure Delivery and Storage of Thing Description</h6>
	    Implement an access control mechanism for the Thing Description.
	    <h6>Use of Secure Transports</h6>
	    Use coaps and https rather than coap and http whenever possible.
	    <h6>Maintaining Privacy</h6>
	    Avoid exposing personally identifiable information in a Thing Description.
	    Avoid exposing an immutable hardware identifier.
	    <h6>Minimize API Functionality</h6>
	    APIs should only provide the functionality necessary, and no more.
	    Devices should be strongly encapsulated.
	    Consider different levels of access for different users.
	    <h5>Testing</h5>
	    Penetration testing of a Test Thing implemented using an Open-Source implementation will be performed.
    </section>

<section   id="acknowledgements" class="appendix normative">
<h1>Acknowledgements</h1>
<p>This document contains a significant contribution from Web of Things members: ...</p>
</section>

  </body>
</html>
